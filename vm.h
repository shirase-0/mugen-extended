#ifndef __MUVIRTUALMACHINE__
#define __MUVIRTUALMACHINE__

VM *vm_init();
void vm_set_players(VM *vm, Player *p1, Player *p2);
void vm_init_func_table(VM *vm);
// I'll likely need to implement a bunch of free functions throughout all the other files to use
// in this function
void free_vm();

float vm_execute(VM *vm, Instruction *p_inst);
void vm_pop_value(VM *vm);
void vm_push_value(VM *vm);
void vm_add_op(VM *vm);
void vm_sub_op(VM *vm);
void vm_mul_op(VM *vm);
void vm_div_op(VM *vm);
void vm_equal_op(VM *vm);
void vm_not_equal(VM *vm);
void vm_less(VM *vm);
void vm_greater(VM *vm);
void vm_less_equal(VM *vm);
void vm_greater_equal(VM *vm);
void vm_inter_val_op1(VM *vm);
void vm_inter_val_op2(VM *vm);
void vm_inter_val_op3(VM *vm);
void vm_inter_val_op4(VM *vm);
void vm_inter_val_op5(VM *vm);
void vm_inter_val_op6(VM *vm);
void vm_inter_val_op7(VM *vm);
void vm_inter_val_op8(VM *vm);
void vm_log_not(VM *vm);
void vm_log_and(VM *vm);
void vm_log_or(VM *vm);
void vm_log_xor(VM *vm);
void vm_not(VM *vm);
void vm_and(VM *vm);
void vm_or(VM *vm);
void vm_xor(VM *vm);
void vm_square(VM *vm);
void vm_neg(VM *vm);
void vm_abs(VM *vm);
void vm_acos(VM *vm);
void vm_alive(VM *vm);
void vm_anim(VM *vm);
void vm_anim_elem(VM *vm);
void vm_anim_elem_no(VM *vm);
void vm_anim_elem_time(VM *vm);
void vm_anim_exist(VM *vm);
void vm_anim_time(VM *vm);
void vm_asin(VM *vm);
void vm_atan(VM *vm);
void vm_author_name(VM *vm);
void vm_back_edge_body_dist(VM *vm);
void vm_back_edge_dist(VM *vm);
void vm_can_recover(VM *vm);
void vm_ceil(VM *vm);
void vm_command(VM *vm);
void vm_const(VM *vm);
void vm_cos(VM *vm);
void vm_ctrl(VM *vm);
void vm_draw_game(VM *vm);
void vm_exp(VM *vm);
void vm_facing(VM *vm);
void vm_floor(VM *vm);
void vm_front_edge_body_dist(VM *vm);
void vm_front_edge_dist(VM *vm);
void vm_fvar(VM *vm);
void vm_game_time(VM *vm);
void vm_get_hit_var(VM *vm);
void vm_hit_count(VM *vm);
//void vm_hitdef_attr(VM *vm); // This was commented out in the original code
void vm_hit_fall(VM *vm);
void vm_hit_over(VM *vm);
void vm_hit_pause_time(VM *vm);
void vm_hit_shake_over(VM *vm);
void vm_hit_vel(VM *vm);
void vm_player_ident(VM *vm);
void vm_if_else(VM *vm);
void vm_in_guard_dist(VM *vm);
void vm_is_helper(VM *vm);
void vm_is_home_team(VM *vm);
void vm_life(VM *vm);
void vm_life_max(VM *vm);
void vm_log_n(VM *vm);
void vm_log(VM *vm);
void vm_lose(VM *vm);
void vm_match_no(VM *vm);
void vm_match_over(VM *vm);
void vm_move_contact(VM *vm);
void vm_move_guarded(VM *vm);
void vm_move_hit(VM *vm);
void vm_move_type(VM *vm);
void vm_move_reversed(VM *vm);
void vm_name(VM *vm);
void vm_num_enemy(VM *vm);
void vm_num_explod(VM *vm);
void vm_num_helper(VM *vm);
void vm_num_partner(VM *vm);
void vm_num_proj(VM *vm);
void vm_num_proj_id(VM *vm);
void vm_num_target(VM *vm);
void vm_p2_body_dist(VM *vm);
void vm_p2_dist(VM *vm);
void vm_p2_life(VM *vm);
void vm_p2_move_type(VM *vm);
void vm_p2_name(VM *vm);
void vm_p2_state_no(VM *vm);
void vm_p2_state_type(VM *vm);
void vm_p3_name(VM *vm);
void vm_p4_name(VM *vm);
void vm_pal_no(VM *vm);
void vm_parent_dist(VM *vm);
void vm_pi(VM *vm);
void vm_pos(VM *vm);
void vm_power(VM *vm);
void vm_power_max(VM *vm);
void vm_player_id_exist(VM *vm); // Commented out in p_func_table
void vm_prev_state_no(VM *vm); // Commented out in p_func_table
void vm_proj_cancel_time(VM *vm);
void vm_proj_contact(VM *vm);
void vm_proj_contact_time(VM *vm);
void vm_proj_guarded(VM *vm);
void vm_proj_guarded_time(VM *vm);
void vm_random(VM *vm);
void vm_root_dist(VM *vm);
void vm_round_no(VM *vm);
void vm_rounds_existed(VM *vm);
void vm_round_state(VM *vm);
void vm_screen_pos(VM *vm);
void vm_self_anim_exist(VM *vm);
void vm_sin(VM *vm);
void vm_state_no(VM *vm);
void vm_state_type(VM *vm);
void vm_sys_fvar(VM *vm);
void vm_sys_var(VM *vm);
void vm_tan(VM *vm);
void vm_team_mode(VM *vm);
void vm_team_side(VM *vm);
void vm_ticks_per_second(VM *vm);
void vm_time(VM *vm);
void vm_uniq_hit_count(VM *vm);
void vm_var(VM *vm);
void vm_vel(VM *vm);
void vm_win(VM *vm);

void vm_nop();
void vm_modop(VM *vm);

void vm_save(VM *vm);
void vm_restore(VM *vm);

#endif